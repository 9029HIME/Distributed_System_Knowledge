# 服务雪崩

## 23-服务雪崩与解决方案

微服务之间的调用本质是网络请求，网络请求就意味着有可能会因为网络原因导致下游服务不可用，甚至下游服务本身异常导致服务不可用。如1个请求打到服务A，服务A为了完成请求的业务，需要调用服务B，若服务A与B之间的网络发生故障，或者服务B本身由于代码异常导致无法响应正常结果给服务A，这个请求就会占用着服务A的线程，导致这个线程不可用。**当这类请求累计到一定次数，服务A的Tomcat请求线程数耗尽，最终导致服务A整个不可用**。服务A在微服务中一旦不可用，就有可能作为“服务B”这个角色导致上游服务也不可用，从而导致整个微服务瘫痪，这就是服务雪崩。

为了解决服务雪崩，以上面的服务AB举例，其实有以下几种方案：

1. 超时时间：设置超时时间，让服务A对服务B的请求是有兜底的，当A对B的请求时间超过timeout，服务A抛出异常给上层方法处理，使本次请求结束。但是！！！超时时间要怎么设，设多少是一个比较复杂的问题。如果太短，服务B来不及响应，整个请求就结束了。如果太长，在超时时间之前若发生大批量同样的请求，最终的结局也是服务雪崩。所以设置超时时间并不是一个最优解。
2. 线程隔离：按照业务划分线程池，让某个业务的请求到达Tomcat后，只使用这个业务的线程池来处理，这样即使下游发生了故障，也只是耗尽了这个线程池的资源，并非整个Tomcat。当然，这个方法也不太好用，不仅难划分线程池，而且效率很差。
3. 熔断降级：通过**断路器**统计业务执行的异常比例，如果超出这个阈值则会熔断该业务，拦截这个业务的一切请求。当断路器发现服务A请求服务B的异常次数达到一定阈值时，服务A再次请求服务B会直接抛出一个异常，不让A访问下去，上层方法需要根据这个异常自定义解决方案。
4. 流量控制：限制业务访问的QPS，避免服务B因为流量的激增而发生故障。当然这个属于预防方案，并非服务异常的应对方案。

## 24-服务保护

为了避免知识点23提出的服务雪崩，一般都是使用现有的服务保护框架，它整合了知识点23提出的解决方案，可以达到预防与应对的作用。目前主流有Sentinel与Hystrix这两种。Hystrix是早期学习微服务的时候了解到的框架，但是它已经停止维护了，而且相比Sentinel也有很多缺点，所以目前和将来，更多会关注于Sentinel的使用，以下是它们两个之间的差别：

|                        |            Sentinel            |      Hystrix      |
| ---------------------- | :----------------------------: | :---------------: |
| 线程隔离策略           | 信号量（联动OS笔记03 同步.md） | 线程池隔离/信号量 |
| 熔断降级策略           |    基于满调用比例和异常比例    |   基于失败比例    |
| 实时指标实现（TODO）   |        滑动窗口（TODO）        | 滑动窗口（TODO）  |
| 规则配置               |         支持多种数据源         |  支持多种数据源   |
| 扩展性                 |           多个扩展点           |       插件        |
| 基于注解整合           |              支持              |       支持        |
| 限流（流量控制）       |    基于QPS、调用关系的限流     |    有限的支持     |
| 流量整形               |    支持慢启动、匀速排队模式    |      不支持       |
| 系统自适应保护（TODO） |              支持              |      不支持       |
| 控制台                 |            非常完善            |      不完善       |

# 整合Sentinel

## 25-sentinel控制台的搭建

有点类似Nacos控制台，Sentinel关键实现需要耦合在服务实例的代码里，控制台起到监控和热更改的作用，首先下载官方提供的sentinel-dashboard的jar包，它已经集成好前后端功能了，只需